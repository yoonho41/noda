// C:\VSCode\react\project\noda\src\pages\Message.js
import React, { Fragment, useEffect, useMemo, useState } from 'react';
import styles from './Message.module.scss';
import MessageSend from './MessageSend';
import messageService from '../../services/messageService';

import "eva-icons/style/eva-icons.css";
import Swal from "sweetalert2";
import messageFilesService from '../../services/messageFilesService';


/** why: ÎÇ†Ïßú ÌëúÍ∏∞ Í∞ÄÎèÖÏÑ± ÌôïÎ≥¥ */
function formatDate(iso) {
  try {
    const d = new Date(iso);
    return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')} ${String(d.getHours()).padStart(2, '0')}:${String(d.getMinutes()).padStart(2, '0')}`;
  } catch {
    return iso;
  }
}

/** ÏÉòÌîå ÌïòÎìúÏΩîÎî© Îç∞Ïù¥ÌÑ∞ */

const SAMPLE_MESSAGES1 = []

const SAMPLE_MESSAGES = [
  {
    id: 'm1',
    sender_id: 'ÌôçÍ∏∏Îèô',
    fromEmail: 'hong@corp.local',
    receiver_id: 'ÎÇò',
    toEmail: 'me@corp.local',
    subject: '10Ïõî Ï†ïÍ∏∞ ÌöåÏùò ÏùºÏ†ï Í≥µÏú†',
    content: 'ÏïàÎÖïÌïòÏÑ∏Ïöî,\nÏù¥Î≤à Ï£º Í∏àÏöîÏùº 14ÏãúÏóê ÌöåÏùòÏã§ AÏóêÏÑú ÏßÑÌñâÌï©ÎãàÎã§.\nÏïàÍ±¥: Î∂ÑÍ∏∞ Ïã§Ï†Å, Ïã†Í∑ú ÌîÑÎ°úÏ†ùÌä∏ ÌÇ•Ïò§ÌîÑ.',
    send_date: '2025-10-23T08:41:00Z',
    unread: true,
    folder: 'inbox',
  },
  {
    id: 'm2',
    sender_id: 'ÎÇò',
    fromEmail: 'me@corp.local',
    receiver_id: 'Í∞úÎ∞úÌåÄ',
    toEmail: 'dev@corp.local',
    subject: 'Î∞∞Ìè¨ Ï≤¥ÌÅ¨Î¶¨Ïä§Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏',
    content: 'Ï≤¥ÌÅ¨Î¶¨Ïä§Ìä∏ 1.2 Î≤ÑÏ†Ñ Î∞∞Ìè¨ÌñàÏäµÎãàÎã§. Î≥ÄÍ≤ΩÏÇ¨Ìï≠ ÌôïÏù∏ Î∂ÄÌÉÅÎìúÎ¶ΩÎãàÎã§.',
    send_date: '2025-10-22T14:15:00Z',
    unread: false,
    folder: 'sent',
  },
  {
    id: 'm3',
    sender_id: 'Î∞ïÎ≥¥Îùº',
    fromEmail: 'bora@corp.local',
    receiver_id: 'ÎÇò',
    toEmail: 'me@corp.local',
    subject: '[ÏöîÏ≤≠] Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú',
    content: 'ÏßÄÎÇú Î∂ÑÍ∏∞ Îß§Ï∂ú Îç∞Ïù¥ÌÑ∞ CSVÎ°ú Î∂ÄÌÉÅÎìúÎ†§Ïöî.\nÌïÑÎìú: ÎÇ†Ïßú, ÏÉÅÌíà, Í∏àÏï°, Ï±ÑÎÑê',
    send_date: '2025-10-21T02:10:00Z',
    unread: true,
    folder: 'inbox',
  },
  {
    id: 'm4',
    sender_id: 'Ïù∏ÏÇ¨ÌåÄ',
    fromEmail: 'hr@corp.local',
    receiver_id: 'ÎÇò',
    toEmail: 'me@corp.local',
    subject: 'Ïó∞Îßê Ï†ïÏÇ∞ ÏïàÎÇ¥',
    content: 'Ïó∞Îßê Ï†ïÏÇ∞ ÏùºÏ†ï Î∞è ÌïÑÏöîÏÑúÎ•ò ÏïàÎÇ¥ÎìúÎ¶ΩÎãàÎã§.',
    send_date: '2025-10-20T09:00:00Z',
    unread: false,
    folder: 'inbox',
  },
];



export default function Message() {
  const [messages, setMessages] = useState(SAMPLE_MESSAGES1);
  const [selectedIds, setSelectedIds] = useState(() => new Set());
  const [query, setQuery] = useState('');
  const [sortKey, setSortKey] = useState('date_desc'); // 'date_desc' | 'date_asc' | 'unread'
  const [readingId, setReadingId] = useState(null);

  const [compose, setCompose] = useState({
    open: false,
    mode: 'new', // 'new' | 'reply'
    to: '',
    subject: '',
    content: '',
    replyToId: null,
  });


  const [fileId,setFileId] = useState([]);





  const filtered = useMemo(() => {
    const q = query.trim().toLowerCase();
    let arr = messages.filter((m) => {
      if (!q) return true;
      return (
        m.subject.toLowerCase().includes(q) ||
        m.sender_id.toLowerCase().includes(q) ||
        m.fromEmail.toLowerCase().includes(q) ||
        m.content.toLowerCase().includes(q)
      );
    });
    if (sortKey === 'date_desc') arr = arr.slice().sort((a, b) => new Date(b.send_date) - new Date(a.send_date));
    if (sortKey === 'date_asc') arr = arr.slice().sort((a, b) => new Date(a.send_date) - new Date(b.send_date));
    if (sortKey === 'unread') arr = arr.slice().sort((a, b) => Number(b.unread) - Number(a.unread));
    return arr;
  }, [messages, query, sortKey]);

  const allVisibleIds = filtered.map((m) => m.id);
  const allSelectedOnPage = allVisibleIds.every((id) => selectedIds.has(id)) && allVisibleIds.length > 0;

  function toggleSelect(id) {
    setSelectedIds((prev) => {
      const next = new Set(prev);
      if (next.has(id)) next.delete(id);
      else next.add(id);
      return next;
    });
  }
  function toggleSelectAllVisible() {
    setSelectedIds((prev) => {
      const next = new Set(prev);
      if (allSelectedOnPage) {
        allVisibleIds.forEach((id) => next.delete(id));
      } else {
        allVisibleIds.forEach((id) => next.add(id));
      }
      return next;
    });
  }
  function handleDeleteSelected() {
    if (selectedIds.size === 0) return;

    Swal.fire({
      title: "",
      text: "Ï†ïÎßê ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?",
      icon: "warning",
      showCancelButton: true,
      confirmButtonColor: "#3085d6",
      cancelButtonColor: "#d33",
      confirmButtonText: "ÏÇ≠Ï†úÌïòÍ∏∞",
      cancelButtonText: "Ï∑®ÏÜåÌïòÍ∏∞",
      showClass: {popup:"swal2-show"}
    }).then((result) => {
      if (result.isConfirmed) {
        setMessages((prev) => prev.filter((m) => !selectedIds.has(m.id)));

        for (let id of selectedIds) {
          onDel(id)
        }

        setSelectedIds(new Set());
        if (readingId && !messages.find((m) => m.id === readingId)) setReadingId(null);

        Swal.fire({
          title: "",
          text: "ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§.",
          icon: "success"
        });
      }
    });

  }

  function handelDeleteSingle(id) {
    Swal.fire({
      title: "",
      text: "Ï†ïÎßê ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?",
      icon: "warning",
      showCancelButton: true,
      confirmButtonColor: "#3085d6",
      cancelButtonColor: "#d33",
      confirmButtonText: "ÏÇ≠Ï†úÌïòÍ∏∞",
      cancelButtonText: "Ï∑®ÏÜåÌïòÍ∏∞",
      showClass: {popup:"swal2-show"}
    }).then((result) => {
      if (result.isConfirmed) {
        //setMessages((prev) => prev.filter((m) => !selectedIds.has(m.id)));

        onDel(id)
        onDelFile(id)
        
        setSelectedIds((prev) => {
          const next = new Set(prev);
          next.delete(id);
          return next;
        });
        if (readingId && !messages.find((m) => m.id === readingId)) setReadingId(null);

        Swal.fire({
          title: "",
          text: "ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§.",
          icon: "success"
        });
      }
    });
  }



  function handleMarkRead(unread) {
    if (selectedIds.size === 0) return;
    for (let id of selectedIds) {
      onRead(id)
    }
    setMessages((prev) =>
      prev.map((m) => (selectedIds.has(m.id) ? { ...m, unread } : m))
    );
  }

  function handleMarkUnRead(unread) {
    if (selectedIds.size === 0) return;
    for (let id of selectedIds) {
      onUnRead(id)
    }
    
  }

  function openComposeNew() {
    setCompose({
      open: !compose.open,
      mode: 'new',
      to: '',
      subject: '',
      content: '',
      replyToId: null,
    });
  }

  function openReply(msg) {
    const quoted = `\n\n--- ÏõêÎ≥∏ Î©îÏãúÏßÄ ---\nFrom: ${msg.sender_id} <${msg.fromEmail}>\nDate: ${formatDate(msg.send_date)}\nSubject: ${msg.subject}\n\n${msg.content}`;
    setCompose({
      open: true,
      mode: 'reply',
      // to: `${msg.sender_id} <${msg.fromEmail}>`,
      to: msg.fromEmail,
      subject: msg.subject.startsWith('Re:') ? msg.subject : `Re: ${msg.subject}`,
      content: quoted,
      replyToId: msg.no,
    });
  }

  function handleSend(e) {
    e.preventDefault();
    const now = new Date().toISOString();
    const newMsg = {
      id: `local_${Date.now()}`,
      sender_id: 'ÎÇò',
      fromEmail: 'me@corp.local',
      receiver_id: compose.to || '(ÎØ∏ÏßÄÏ†ï)',
      toEmail: compose.to || '',
      subject: compose.subject || '(Ï†úÎ™© ÏóÜÏùå)',
      content: compose.content || '',
      send_date: now,
      unread: false,
      folder: 'sent',
    };
    setMessages((prev) => [newMsg, ...prev]);
    setCompose({ open: false, mode: 'new', to: '', subject: '', content: '', replyToId: null });
  }

  function handleCancelCompose() {
    setCompose((c) => ({ ...c, open: false }));
  }

  const onFileList = async(id) => {
      const res = await messageFilesService.getFile(id)
      setFileId(res)
      
  }

  function onRowClick(m) {
    
    setReadingId(m.id);

    onFileList(m.id)
    
    

    onRead(m.id)


    if (!m.unread) {
      setMessages((prev) => prev.map((x) => (x.id === m.id ? { ...x, unread: false } : x)));
    }
    scrollPageToBottom()
  }

  const singleSelectedMsg =
    selectedIds.size === 1 ? messages.find((m) => selectedIds.has(m.id)) : null;

  const onData = async() => {
      const res = await messageService.getMessage()
      const message = res.map(m => ({
        ...m,
        id: m.no,
        sender_id: m.sender_id,
        fromEmail: m.sender_id + '@noda.com',
        receiver_id: m.receiver_id,
        toEmail: m.receiver_id + '@noda.com',
        subject: m.subject,
        content: m.content,
        send_date: m.send_date,
        unread: m.is_read,
        folder: 'sent',
      }));
      setMessages(message)
  }

  useEffect(() => {
      onData()
  },[])

  const onDel = (id) => {
    messageService.deleteMessage(id)
    onData()
  }

  const onDelFile = (id) => {
    messageFilesService.deleteFile(id)
    onData()
  }


  const onRead = (id) => {
    messageService.readMessage(id)
    onData()
  }

  const onUnRead = (id) => {
    messageService.unreadMessage(id)
    onData()
  }


  function formatFileSizeFromKB(sizeInKB) {
    const n = Number(sizeInKB);

    if (n < 500) {
      // ÏûÖÎ†•Ïù¥ ÏÜåÏàòÏùº Ïàò ÏûàÏúºÎØÄÎ°ú Î∞òÏò¨Î¶ºÌïòÏó¨ ÍπîÎÅîÌïú Ï†ïÏàò KB ÌëúÍ∏∞
      return `${Math.round(n)} B`;
    }
    if (n < 512000) {
      const mb = n / 1024;
      return `${mb.toFixed(1)} KB`;
    }
    const mb = n / (1024*1024);
    return `${mb.toFixed(1)} MB`;
  }


  function pickFileIcon(mimeType = '', filename = '') {
    const m = String(mimeType || '').toLowerCase();
    const ext = String(filename || '').split('.').pop()?.toLowerCase();

    // 1) MIME Í∏∞Î∞ò Îß§Ìïë
    if (m.startsWith('image/'))   return { icon: 'üñºÔ∏è', label: 'Image' };
    if (m === 'application/pdf')  return { icon: 'üìÑ', label: 'PDF' };
    if (m.includes('word'))       return { icon: 'üìù', label: 'Word' };
    if (m.includes('excel') || m.includes('spreadsheet'))
                                return { icon: 'üìà', label: 'Excel' };
    if (m.includes('powerpoint') || m.includes('presentation'))
                                return { icon: 'üìä', label: 'PowerPoint' };
    if (m.startsWith('text/'))    return { icon: 'üìÑ', label: 'Text' };
    if (m.includes('json'))       return { icon: 'üßæ', label: 'JSON' };
    if (m.startsWith('audio/'))   return { icon: 'üéµ', label: 'Audio' };
    if (m.startsWith('video/'))   return { icon: 'üé¨', label: 'Video' };
    if (m.includes('zip') || m.includes('compressed') || m.includes('gzip') || m.includes('tar'))
                                return { icon: 'üóúÔ∏è', label: 'Archive' };
    if (m === 'application/octet-stream')
                                return { icon: 'üì¶', label: 'Binary' };

    // 2) ÌôïÏû•Ïûê Í∏∞Î∞ò Î≥¥Ï†ï(Î∞±ÏóîÎìúÍ∞Ä MIMEÏùÑ Î™ª Ï£ºÎäî ÏºÄÏù¥Ïä§)
    const byExt = {
      pdf: 'üìÑ', txt: 'üìÑ', md: 'üìÑ',
      png: 'üñºÔ∏è', jpg: 'üñºÔ∏è', jpeg: 'üñºÔ∏è', gif: 'üñºÔ∏è', webp: 'üñºÔ∏è', svg: 'üñºÔ∏è',
      doc: 'üìù', docx: 'üìù',
      xls: 'üìà', xlsx: 'üìà', csv: 'üìà',
      ppt: 'üìä', pptx: 'üìä',
      zip: 'üóúÔ∏è', rar: 'üóúÔ∏è', '7z': 'üóúÔ∏è', gz: 'üóúÔ∏è', tar: 'üóúÔ∏è',
      mp3: 'üéµ', wav: 'üéµ', flac: 'üéµ',
      mp4: 'üé¨', mov: 'üé¨', avi: 'üé¨', mkv: 'üé¨',
      json: 'üßæ',
    };
    if (ext && byExt[ext]) {
      const labelMap = {
        'üìÑ': 'Document', 'üñºÔ∏è': 'Image', 'üìù': 'Word',
        'üìà': 'Spreadsheet', 'üìä': 'Presentation',
        'üóúÔ∏è': 'Archive', 'üéµ': 'Audio', 'üé¨': 'Video', 'üßæ': 'JSON',
      };
      return { icon: byExt[ext], label: labelMap[byExt[ext]] || 'File' };
    }

    // 3) Í∏∞Î≥∏Í∞í
    return { icon: 'üìÅ', label: 'File' };
  }


  function scrollPageToBottom(smooth = true) {
    let bottom = document.body.scrollHeight;
    window.scrollTo({
      top: bottom,
      behavior: smooth ? "smooth" : "auto",
    });
  }


  return (
    <div className={styles.root}>
      {/* Ìà¥Î∞î */}
      <div className={styles.toolbar}>
        <div className={styles.leftGroup}>
          <button type="button" className={styles.primaryBtn} onClick={openComposeNew}>
            {
                compose.open?'ÏûëÏÑ± Ï∑®ÏÜå':'ÏÉà Î©îÏÑ∏ÏßÄ'
            }
          </button>
          <button
            type="button"
            className={styles.dangerBtn}
            onClick={handleDeleteSelected}
            disabled={selectedIds.size === 0}
            title="ÏÑ†ÌÉù Ìï≠Î™© ÏÇ≠Ï†ú"
          >
            ÏÇ≠Ï†ú
          </button>
          <button
            type="button"
            className={styles.neutralBtn}
            onClick={() => singleSelectedMsg && openReply(singleSelectedMsg)}
            disabled={!singleSelectedMsg}
            title="ÏÑ†ÌÉùÌïú 1Í±¥Ïóê ÎãµÏû•"
          >
            ÎãµÏû•
          </button>
          <button
            type="button"
            className={styles.neutralBtn}
            onClick={() => handleMarkUnRead(false)}
            disabled={selectedIds.size === 0}
            title="ÏÑ†ÌÉù Ìï≠Î™©ÏùÑ ÏùΩÏßÄ ÏïäÏùåÏúºÎ°ú ÌëúÏãú"
          >
            ÏïàÏùΩÏùå
          </button>
          <button
            type="button"
            className={styles.neutralBtn}
            onClick={() => handleMarkRead(true)}
            disabled={selectedIds.size === 0}
            title="ÏÑ†ÌÉù Ìï≠Î™©ÏùÑ ÏùΩÏùåÏúºÎ°ú ÌëúÏãú"
          >
            ÏùΩÏùå
          </button>
        </div>
        <div className={styles.rightGroup}>
          <input
            className={styles.searchInput}
            value={query}
            onChange={(e) => setQuery(e.target.value)}
            placeholder="Í≤ÄÏÉâ: Ï†úÎ™©/Î≥¥ÎÇ∏ÏÇ¨Îûå/Î≥∏Î¨∏"
          />
          <select
            className={styles.select}
            value={sortKey}
            onChange={(e) => setSortKey(e.target.value)}
          >
            <option value="date_desc">ÏµúÍ∑ºÏàú</option>
            <option value="date_asc">Ïò§ÎûòÎêúÏàú</option>
            <option value="unread">ÏïàÏùΩÏùå Ïö∞ÏÑ†</option>
          </select>
        </div>
      </div>

      {/* Ïª¥Ìè¨Ï¶à(ÏûëÏÑ±) */}
      {compose.open && (
        <MessageSend onData={onData} compose={compose} setCompose={setCompose}/>
      )}

      {/* Î¶¨Ïä§Ìä∏ Ìó§Îçî */}
      <div className={`${styles.row} ${styles.headerRow}`}>
        <div className={styles.colCheck}>
          <input
            type="checkbox"
            checked={allSelectedOnPage}
            onChange={toggleSelectAllVisible}
            aria-label="Ï†ÑÏ≤¥ ÏÑ†ÌÉù"
          />
        </div>
        <div className={styles.colFrom}>Î≥¥ÎÇ∏ÏÇ¨Îûå</div>
        <div className={styles.colSubject}>Ï†úÎ™©</div>
        <div className={styles.colDate}>ÎÇ†Ïßú</div>
        <div className={styles.colActions}>ÏûëÏóÖ</div>
      </div>

      {/* Î¶¨Ïä§Ìä∏ Î∞îÎîî */}
      <div className={styles.list}>
        {filtered.map((m) => {
          const selected = selectedIds.has(m.id);
          return (
            <div
              key={m.id}
              className={`${styles.row} ${selected ? styles.selected : ''} ${m.unread ? styles.read : styles.unread}`}
              onClick={() => onRowClick(m)}
              role="button"
              tabIndex={0}
              onKeyDown={(e) => e.key === 'Enter' && onRowClick(m)}
            >
              <div className={styles.colCheck} onClick={(e) => e.stopPropagation()}>
                <input
                  type="checkbox"
                  checked={selected}
                  onChange={() => toggleSelect(m.id)}
                  aria-label={`${m.subject} ÏÑ†ÌÉù`}
                />
              </div>
              <div className={styles.colFrom}>
                <div className={styles.sender_id}>{m.sender_id}</div>
                <div className={styles.fromEmail}>{m.fromEmail}</div>
              </div>
              <div className={styles.colSubject}>
                {
                  m.is_important ?
                    <div className={styles.subject}>
                      üö® {m.subject}
                    </div> :
                    <div className={styles.subject}>
                      {m.subject}
                    </div>
                }
                
                <div className={styles.preview}>{m.content.slice(0, 80)}</div>
              </div>
              <div className={styles.colDate}>{formatDate(m.send_date)}</div>
              <div className={styles.colActions} onClick={(e) => e.stopPropagation()}>
                <button className={styles.linkBtn} type="button" onClick={() => openReply(m)}>ÎãµÏû•</button>
                <button className={styles.linkBtn} type="button" onClick={() => {
                  // setSelectedIds(new Set([m.id]));
                  // handleDeleteSelected();
                  handelDeleteSingle(m.id)
                }}>ÏÇ≠Ï†ú</button>
                <button className={styles.linkBtn} type="button" onClick={() => onUnRead(m.id)}>ÏïàÏùΩÏùå</button>
              </div>
              
            </div>
            
          );
        })}
        {filtered.length === 0 && (
          <div className={styles.empty}>ÌëúÏãúÌï† Î©îÏÑ∏ÏßÄÍ∞Ä ÏóÜÏäµÎãàÎã§.</div>
        )}
        
      </div>

      {/* ÏùΩÍ∏∞ Ìå®ÎÑê(ÏÑ†ÌÉù Ïãú) */}
      {!!readingId && (
        <ReadingPane
          message={messages.find((m) => m.id === readingId)}
          onClose={() => setReadingId(null)}
          handelDeleteSingle={handelDeleteSingle}
          readingId={readingId}
          fileId={fileId}
          formatFileSizeFromKB={formatFileSizeFromKB}
          pickFileIcon={pickFileIcon}
        />
      )}

      
    </div>
  );
}

function ReadingPane({ message, onClose, handelDeleteSingle, readingId, fileId, formatFileSizeFromKB, pickFileIcon }) {
  if (!message) return null;
  return (
    <div className={styles.readingPane}>
      <div className={styles.readingHeader}>
        <div>
          <div className={styles.readingSubject}>{message.subject}</div>
          <div className={styles.readingMeta}>
            From {message.sender_id} &lt;{message.fromEmail}&gt; ¬∑ {formatDate(message.send_date)}
          </div>
        </div>
        <div className={styles.paneBtns}>
          
          <button className={`${styles.neutralBtn} ${styles.paneBtn}`} onClick={onClose} type="button">ÎãµÏû•</button>
          <button className={`${styles.neutralBtn} ${styles.paneBtn}`} onClick={() => handelDeleteSingle(readingId)} type="button">ÏÇ≠Ï†ú</button>
          <button className={`${styles.neutralBtn} ${styles.paneBtn}`} onClick={onClose} type="button"> ‚úñ </button>
        </div>
        
      </div>
      {
        fileId.length!==0 &&
        <div className={styles.messageFiles}>
          {
            fileId.map(items => 
              <Fragment>
                <a href={items.downloadUrl} rel="noreferrer">
                  {pickFileIcon(items.mimeType, items.originalName).icon} {items.originalName} ({formatFileSizeFromKB(items.size)})
                </a>
                <br/>
              </Fragment>
            )
          }
          
        </div>
      }
      
      <pre className={styles.readingContent}>{message.content}</pre>
    </div>
  );
}
